from pysat.formula import CNF
from pysat.solvers import Solver

def rna_design_to_sat(n, base_pairs):
    cnf = CNF()
    
    base_map = {'A': 1, 'C': 2, 'G': 3, 'U': 4}
    variables = {(i, base): 4 * (i - 1) + base_map[base] for i in range(1, n + 1) for base in 'ACGU'}

    # Single base constraint: each position must have exactly one base
    for i in range(1, n + 1):
        cnf.append([variables[(i, base)] for base in 'ACGU'])
        for base1 in 'ACGU':
            for base2 in 'ACGU':
                if base1 != base2:
                    cnf.append([-variables[(i, base1)], -variables[(i, base2)]])
    
    # Pairing constraints for the given base pairs
    for (i, j) in base_pairs:
        cnf.append([-variables[(i, 'A')], variables[(j, 'U')]])
        cnf.append([-variables[(i, 'U')], variables[(j, 'A')]])
        cnf.append([-variables[(i, 'C')], variables[(j, 'G')]])
        cnf.append([-variables[(i, 'G')], variables[(j, 'C')]])
    
    # Ensure pseudoknot-free structure
    for (i, j) in base_pairs:
        for (k, l) in base_pairs:
            if i < k < j < l or k < i < l < j:
                for base1 in 'ACGU':
                    for base2 in 'ACGU':
                        cnf.append([-variables[(i, base1)], -variables[(k, base2)]])
                        cnf.append([-variables[(j, base1)], -variables[(l, base2)]])
    
    # # Constraint to ensure potential pairings within subsequence [i, j] are less than base_pairs
    # total_base_pairs = len(base_pairs)
    # for i in range(1, n + 1):
    #     for j in range(i + 1, n + 1):
    #         if (i, j) not in base_pairs:
    #             potential_pair_vars = []
    #             for k in range(i + 1, j):
    #                 for l in range(k + 1, j):
    #                     if (k, l) not in base_pairs and (k, l) in [('A', 'U'), ('U', 'A'), ('C', 'G'), ('G', 'C')]:
    #                         potential_pair_vars.append(variables[(k, 'A')])
    #                         potential_pair_vars.append(variables[(l, 'U')])
    #                         potential_pair_vars.append(variables[(k, 'U')])
    #                         potential_pair_vars.append(variables[(l, 'A')])
    #                         potential_pair_vars.append(variables[(k, 'C')])
    #                         potential_pair_vars.append(variables[(l, 'G')])
    #                         potential_pair_vars.append(variables[(k, 'G')])
    #                         potential_pair_vars.append(variables[(l, 'C')])
    #             if potential_pair_vars:
    #                 # Ensure the sum of these potential pairs is less than total_base_pairs
    #                 cnf.append([-var for var in potential_pair_vars[:total_base_pairs]])

    return cnf, variables

outs = []
def solve_rna_design(n, base_pairs):
    cnf, variables = rna_design_to_sat(n, base_pairs)
    with Solver(bootstrap_with=cnf) as solver:
        while solver.solve():
            solution = solver.get_model()
            if not solution:
                print('No solution found')
                break
            rna_sequence = [''] * n
            for (i, base), var in variables.items():
                if var in solution:
                    rna_sequence[i-1] = base
            # print(f'RNA Sequence: {rna_sequence}', analyze_design(base_pairs, rna_sequence))
            outs.append((analyze_design2(base_pairs, rna_sequence), "".join(rna_sequence)))
            # Block the current solution
            solver.add_clause([-v for v in solution if v > 0])


def analyze_design(target_structure_pairs, sequence):
    # count the number of base pairs that can be formed other than the target structure
    count = 0
    for i in range(0, len(sequence)):
        for j in range(i + 1, len(sequence)):
            if (sequence[i], sequence[j]) in [('A', 'U'), ('U', 'A'), ('C', 'G'), ('G', 'C')]:
                if (i + 1, j + 1) not in target_structure_pairs:
                    count += 1
    return count


def analyze_design2(pairs, sequence):
    struc = ['.' for _ in range(len(sequence))]
    for (i, j) in pairs:
        struc[i - 1] = '('
        struc[j - 1] = ')'
    def can_pair(base1, base2):
        return (base1, base2) in [('A', 'U'), ('U', 'A'), ('C', 'G'), ('G', 'C')]
    total_distance = 0
    for i in range(len(sequence)):
        mult = 1
        if struc[i] == '.':
            mult = 2.01
            
        lx, rx = i + 1, len(sequence) - i
        for h in range(i - 1, -1, -1):
            if can_pair(sequence[h], sequence[i]):
                lx = i - h
                break
        for j in range(i + 1, len(sequence)):
            if can_pair(sequence[i], sequence[j]):
                rx = j - i
                break
        # print(sequence[i], lx, rx)
        total_distance += (lx + rx) * mult
    return total_distance

print(analyze_design2([(1, 2), (4, 5)], 'GCACG'))
        

        
def get_base_pairs(struc):
    stack = []
    base_pairs = []
    for i, base in enumerate(struc):
        if base == '(':
            stack.append(i)
        elif base == ')':
            j = stack.pop()
            base_pairs.append((j + 1, i + 1))
    return base_pairs

# Example usage
# struc = '()(()((.)))'
# struc = '(()()((.)))'
# struc = '(())()'
# struc = '(((.)))'
# struc = '(()()((.)))'
struc = '().()'
struc = '()(()((.)))'
struc = '.(((..)()()))'
# print(analyze_design(get_base_pairs(struc), 'AAUCGGACUCU'))

n = len(struc)
base_pairs = get_base_pairs(struc)
print(f'Base pairs: {base_pairs}')
solve_rna_design(n, base_pairs)
sorted_outs = sorted(outs, key=lambda x: -x[0])
print(min(sorted_outs))
print(max(sorted_outs))

# print all the max
for ans in sorted_outs: 
    if ans[0] == max(sorted_outs)[0]:
        print(ans)


# for ans in sorted_outs: 
#     print(ans)
# rna_sequence = solve_rna_design(n, base_pairs)
# print(f'RNA Sequence: {rna_sequence}')